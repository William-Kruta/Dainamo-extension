You provided this code to me: 

// sidepanel.js -> inside sendMessage function

      // ... (rest of the function before getting page content)

      let pageContent = null; // Reset pageContent for this message

      if (contentAwarenessEnabled && chrome.runtime) {
        console.log("Sidepanel: Requesting page content...");
        try {
          const pageData = await new Promise((resolve, reject) => {
            chrome.runtime.sendMessage({ action: "getPageContent" }, (response) => {
              if (chrome.runtime.lastError) {
                console.error("Sidepanel: Error receiving page content:", chrome.runtime.lastError.message);
                reject(new Error(chrome.runtime.lastError.message));
              } else if (response && response.error) {
                 // Handle errors reported by background script (e.g., restricted page, script failure)
                 console.warn("Sidepanel: Page context retrieval warning:", response.error);
                 // Resolve with the error info, content will be null
                 resolve({ content: null, title: response.title, url: response.url, error: response.error });
              } else if (response) {
                 console.log("Sidepanel: Received page content successfully.");
                 resolve(response); // Contains { content, title, url, error: null }
              } else {
                 // This case might indicate an issue in the background script's response logic
                 console.error("Sidepanel: Received empty/invalid response for getPageContent.");
                 reject(new Error("Received empty response from background script"));
              }
            });
          });

          // Check if content was successfully retrieved AND is not null/empty
          if (pageData && pageData.content) {
            pageContent = pageData.content; // Store for the badge later
            const pageInfo = `
Current page title: ${pageData.title || 'N/A'}
Current page URL: ${pageData.url || 'N/A'}
Page content snippet:
---
${pageData.content.substring(0, 1500)}${ // Keep truncation logic
              pageData.content.length > 1500 ? "... (content truncated)" : ""
            }
---
            `.trim();

            // Prepend context to the user's actual message
            contextEnhancedPrompt = `Based on the following context from the current webpage:
${pageInfo}

Please answer the user's query: ${userMessage}`; // Clearer structure
            console.log("Sidepanel: Using page context.");

          } else if (pageData && pageData.error) {
             // Inform user that context couldn't be retrieved, use original prompt
             addMessageToChat("system", `Note: Could not use page context. Reason: ${pageData.error}`);
             console.warn("Sidepanel: Proceeding without page context due to error:", pageData.error);
             contextEnhancedPrompt = userMessage; // Fallback to original message
          } else {
             // Content was null/empty even without an explicit error
             addMessageToChat("system", `Note: Page context could not be retrieved or was empty.`);
             console.warn("Sidepanel: Proceeding without page context (content was null/empty).");
             contextEnhancedPrompt = userMessage; // Fallback to original message
          }
        } catch (error) {
          console.error("Sidepanel: Failed to get page content:", error);
          addMessageToChat("system", `Error retrieving page context: ${error.message}. Using original query.`);
          contextEnhancedPrompt = userMessage; // Fallback to original message
        }
      } else {
           // Content awareness is off, use original message
           contextEnhancedPrompt = userMessage;
           console.log("Sidepanel: Content awareness is OFF.");
      }

      // --- Now make the API call using `contextEnhancedPrompt` ---
      console.log("Sidepanel: Sending prompt to Ollama:", contextEnhancedPrompt);

      // Use memory if enabled
      if (memoryEnabled && messageHistory.length > 0) {
        // Add the potentially context-enhanced user message to history
        messageHistory.push({
          role: "user",
          content: contextEnhancedPrompt, // Use the potentially modified prompt
        });
        // ... rest of memory logic
        response = await generateOllamaResponseWithMemory(
          messageHistory,
          selectedModel
        );
        messageHistory.push({
          role: "assistant",
          content: response,
        });

      } else {
        // Generate response without memory (or first message with memory on)
        response = await generateOllamaResponse(
          contextEnhancedPrompt, // Use the potentially modified prompt
          selectedModel
        );
        if (memoryEnabled) {
          messageHistory = [
            { role: "user", content: contextEnhancedPrompt },
            { role: "assistant", content: response },
          ];
        }
      }

      // Replace "Thinking..." with the actual response
      updateMessage(thinkingId, "bot", formatBotResponse(response));

      // Add badge *only* if pageContent was successfully retrieved in *this* turn
      if (contentAwarenessEnabled && pageContent) {
        const messageDiv = document.getElementById(thinkingId);
        if (messageDiv) { // Check if message still exists
             const pageContextBadge = document.createElement("div");
             pageContextBadge.className = "page-context-badge";
             pageContextBadge.textContent = "Used page context";
             // Append badge inside the message content for better layout
             messageDiv.querySelector('.message-content')?.appendChild(pageContextBadge);
        }
      }

    } catch (error) {
       // ... (existing error handling for API call)
        updateMessage(
            thinkingId,
            "system",
            `Error: ${error.message || "Failed to get response"}`
        );
       console.error("Ollama API error:", error);
    }

// ... (rest of sendMessage function)





Here is my current function. Can you rewrite it with the code you provided?


async function sendMessage() {
    // Add the 'async' keyword here
    const userMessage = userInput.value.trim();
    if (!userMessage) return; // Add user message to chat

    addMessageToChat("user", userMessage);
    userInput.value = ""; // Check connection before sending

    if (!(await checkOllamaConnection())) {
      addMessageToChat(
        "system",
        "Unable to connect to Ollama. Please check your connection settings."
      );
      return;
    } // Show thinking indicator

    const thinkingId = addMessageToChat("bot", "Thinking...");

    try {
      const selectedModel = modelSelect.value;
      let response;
      let contextEnhancedPrompt = userMessage;
      let pageContent = null; // Get page content if feature is enabled

      if (contentAwarenessEnabled && chrome.runtime) {
        try {
          const pageData = await new Promise((resolve) => {
            chrome.runtime.sendMessage(
              { action: "getPageContent" },
              (response) => {
                resolve(response);
              }
            );
          });

          if (pageData && pageData.content) {
            pageContent = pageData.content;
            const pageInfo = `
      Current page: ${pageData.title} (${pageData.url})
      Page content: ${pageData.content.substring(0, 1500)}${
              pageData.content.length > 1500 ? "... (content truncated)" : ""
            }
                `.trim(); // Create a structured prompt with the page content

            contextEnhancedPrompt = `
      I want you to act as an assistant with awareness of the current webpage I'm viewing.
      Here is information about the current page:
      
      ${pageInfo}
      
      With this context in mind, please respond to my query:
      ${userMessage}
                `.trim();
          }
        } catch (error) {
          console.error("Error getting page content:", error);
        }
      } // Use memory if enabled

      if (memoryEnabled && messageHistory.length > 0) {
        // Add the new user message to history, with context if available
        messageHistory.push({
          role: "user",
          content: contextEnhancedPrompt,
        }); // Generate response with memory

        response = await generateOllamaResponseWithMemory(
          messageHistory,
          selectedModel
        ); // Add the response to memory

        messageHistory.push({
          role: "assistant",
          content: response,
        });
      } else {
        // Generate response without memory
        response = await generateOllamaResponse(
          contextEnhancedPrompt,
          selectedModel
        ); // If memory is enabled, start tracking

        if (memoryEnabled) {
          messageHistory = [
            { role: "user", content: contextEnhancedPrompt },
            { role: "assistant", content: response },
          ];
        }
      } // Replace thinking with actual response

      updateMessage(thinkingId, "bot", formatBotResponse(response)); // If page context was used, add a small indicator

      if (contentAwarenessEnabled && pageContent) {
        const messageDiv = document.getElementById(thinkingId);
        const pageContextBadge = document.createElement("div");
        pageContextBadge.className = "page-context-badge";
        pageContextBadge.textContent = "Used page context";
        messageDiv.appendChild(pageContextBadge);
      }
    } catch (error) {
      updateMessage(
        thinkingId,
        "system",
        `Error: ${error.message || "Failed to get response"}`
      );
      console.error("Ollama API error:", error);
    }
  }